import { IO_TESTNET_PROCESS_ID } from '../constants.js';
import { isProcessConfiguration, isProcessIdConfiguration, } from '../io.js';
import { defaultArweave } from './arweave.js';
import { AOProcess } from './contracts/ao-process.js';
import { InvalidContractConfigurationError } from './error.js';
export class IO {
    static init(config) {
        if (config && config.signer) {
            const { signer, ...rest } = config;
            return new IOWriteable({
                ...rest,
                signer,
            });
        }
        return new IOReadable(config);
    }
}
export class IOReadable {
    process;
    arweave;
    constructor(config, arweave = defaultArweave) {
        if (!config) {
            this.process = new AOProcess({
                processId: IO_TESTNET_PROCESS_ID,
            });
        }
        else if (isProcessConfiguration(config)) {
            this.process = config.process;
        }
        else if (isProcessIdConfiguration(config)) {
            this.process = new AOProcess({
                processId: config.processId,
            });
        }
        else {
            throw new InvalidContractConfigurationError();
        }
        this.arweave = arweave;
    }
    async getInfo() {
        return this.process.read({
            tags: [{ name: 'Action', value: 'Info' }],
        });
    }
    async getEpochSettings(params) {
        const allTags = [
            { name: 'Action', value: 'Epoch-Settings' },
            {
                name: 'Timestamp',
                value: params?.timestamp?.toString() ??
                    (await this.arweave.blocks
                        .getCurrent()
                        .then((block) => {
                        return { timestamp: block.timestamp * 1000 };
                    })
                        .catch(() => {
                        return { timestamp: Date.now() }; // fallback to current time
                    })).timestamp.toString(),
            },
            {
                name: 'Epoch-Index',
                value: params?.epochIndex?.toString(),
            },
        ];
        const prunedTags = allTags.filter((tag) => tag.value !== undefined);
        return this.process.read({
            tags: prunedTags,
        });
    }
    async getEpoch(epoch) {
        const allTags = [
            { name: 'Action', value: 'Epoch' },
            {
                name: 'Timestamp',
                value: epoch?.timestamp?.toString() ??
                    (await this.arweave.blocks
                        .getCurrent()
                        .then((block) => {
                        return { timestamp: block.timestamp * 1000 };
                    })
                        .catch(() => {
                        return { timestamp: Date.now() }; // fallback to current time
                    })).timestamp.toString(),
            },
            {
                name: 'Epoch-Index',
                value: epoch?.epochIndex?.toString(),
            },
        ];
        const prunedTags = allTags.filter((tag) => tag.value !== undefined);
        return this.process.read({
            tags: prunedTags,
        });
    }
    async getArNSRecord({ name, }) {
        return this.process.read({
            tags: [
                { name: 'Action', value: 'Record' },
                { name: 'Name', value: name },
            ],
        });
    }
    async getArNSRecords(pageParams) {
        const allTags = [
            { name: 'Action', value: 'Paginated-Records' },
            { name: 'Cursor', value: pageParams?.cursor?.toString() },
            { name: 'Limit', value: pageParams?.limit?.toString() },
            { name: 'Sort-By', value: pageParams?.sortBy },
            { name: 'Sort-Order', value: pageParams?.sortOrder },
        ];
        const prunedTags = allTags.filter((tag) => tag.value !== undefined);
        return this.process.read({
            tags: prunedTags,
        });
    }
    async getArNSReservedNames() {
        return this.process.read({
            tags: [{ name: 'Action', value: 'Reserved-Names' }],
        });
    }
    async getArNSReservedName({ name, }) {
        return this.process.read({
            tags: [
                { name: 'Action', value: 'Reserved-Name' },
                { name: 'Name', value: name },
            ],
        });
    }
    async getBalance({ address }) {
        return this.process.read({
            tags: [
                { name: 'Action', value: 'Balance' },
                { name: 'Address', value: address },
            ],
        });
    }
    async getBalances(pageParams) {
        const allTags = [
            { name: 'Action', value: 'Paginated-Balances' },
            { name: 'Cursor', value: pageParams?.cursor?.toString() },
            { name: 'Limit', value: pageParams?.limit?.toString() },
            { name: 'Sort-By', value: pageParams?.sortBy },
            { name: 'Sort-Order', value: pageParams?.sortOrder },
        ];
        const prunedTags = allTags.filter((tag) => tag.value !== undefined);
        return this.process.read({
            tags: prunedTags,
        });
    }
    async getGateway({ address, }) {
        return this.process.read({
            tags: [
                { name: 'Action', value: 'Gateway' },
                { name: 'Address', value: address },
            ],
        });
    }
    async getGateways(pageParams) {
        const allTags = [
            { name: 'Action', value: 'Paginated-Gateways' },
            { name: 'Cursor', value: pageParams?.cursor?.toString() },
            { name: 'Limit', value: pageParams?.limit?.toString() },
            { name: 'Sort-By', value: pageParams?.sortBy },
            { name: 'Sort-Order', value: pageParams?.sortOrder },
        ];
        const prunedTags = allTags.filter((tag) => tag.value !== undefined);
        return this.process.read({
            tags: prunedTags,
        });
    }
    async getCurrentEpoch() {
        return this.process.read({
            tags: [
                { name: 'Action', value: 'Epoch' },
                {
                    name: 'Timestamp',
                    value: (await this.arweave.blocks
                        .getCurrent()
                        .then((block) => {
                        return { timestamp: block.timestamp * 1000 };
                    })
                        .catch(() => {
                        return { timestamp: Date.now() }; // fallback to current time
                    })).timestamp.toString(),
                },
            ],
        });
    }
    async getPrescribedObservers(epoch) {
        const allTags = [
            { name: 'Action', value: 'Epoch-Prescribed-Observers' },
            {
                name: 'Timestamp',
                value: epoch?.timestamp?.toString() ??
                    (await this.arweave.blocks
                        .getCurrent()
                        .then((block) => {
                        return { timestamp: block.timestamp * 1000 };
                    })
                        .catch(() => {
                        return { timestamp: Date.now() }; // fallback to current time
                    })).timestamp.toString(),
            },
            {
                name: 'Epoch-Index',
                value: epoch?.epochIndex?.toString(),
            },
        ];
        const prunedTags = allTags.filter((tag) => tag.value !== undefined);
        return this.process.read({
            tags: prunedTags,
        });
    }
    async getPrescribedNames(epoch) {
        const allTags = [
            { name: 'Action', value: 'Epoch-Prescribed-Names' },
            {
                name: 'Timestamp',
                value: epoch?.timestamp?.toString() ??
                    (await this.arweave.blocks
                        .getCurrent()
                        .then((block) => {
                        return { timestamp: block.timestamp * 1000 };
                    })
                        .catch(() => {
                        return { timestamp: Date.now() }; // fallback to current time
                    })).timestamp.toString(),
            },
            {
                name: 'Epoch-Index',
                value: epoch?.epochIndex?.toString(),
            },
        ];
        const prunedTags = allTags.filter((tag) => tag.value !== undefined);
        return this.process.read({
            tags: prunedTags,
        });
    }
    async getObservations(epoch) {
        const allTags = [
            { name: 'Action', value: 'Epoch-Observations' },
            {
                name: 'Timestamp',
                value: epoch?.timestamp?.toString() ??
                    (await this.arweave.blocks
                        .getCurrent()
                        .then((block) => {
                        return { timestamp: block.timestamp * 1000 };
                    })
                        .catch(() => {
                        return { timestamp: `${Date.now()}` }; // fallback to current time
                    })).timestamp.toString(),
            },
            {
                name: 'Epoch-Index',
                value: epoch?.epochIndex?.toString(),
            },
        ];
        const prunedTags = allTags.filter((tag) => tag.value !== undefined);
        return this.process.read({
            tags: prunedTags,
        });
    }
    async getDistributions(epoch) {
        const allTags = [
            { name: 'Action', value: 'Epoch-Distributions' },
            {
                name: 'Timestamp',
                value: epoch?.timestamp?.toString() ??
                    (await this.arweave.blocks
                        .getCurrent()
                        .then((block) => {
                        return { timestamp: block.timestamp * 1000 };
                    })
                        .catch(() => {
                        return { timestamp: Date.now() }; // fallback to current time
                    })).timestamp.toString(),
            },
            {
                name: 'Epoch-Index',
                value: epoch?.epochIndex?.toString(),
            },
        ];
        const prunedTags = allTags.filter((tag) => tag.value !== undefined);
        return this.process.read({
            tags: prunedTags,
        });
    }
    async getTokenCost({ intent, purchaseType, years, name, quantity, }) {
        const allTags = [
            { name: 'Action', value: 'Token-Cost' },
            {
                name: 'Intent',
                value: intent,
            },
            {
                name: 'Name',
                value: name,
            },
            {
                name: 'Years',
                value: years?.toString(),
            },
            {
                name: 'Quantity',
                value: quantity?.toString(),
            },
            {
                name: 'Purchase-Type',
                value: purchaseType,
            },
            {
                name: 'Timestamp',
                value: (await this.arweave.blocks
                    .getCurrent()
                    .then((block) => {
                    return { timestamp: block.timestamp * 1000 };
                })
                    .catch(() => {
                    return { timestamp: Date.now() }; // fallback to current time
                })).timestamp.toString(),
            },
        ];
        const prunedTags = allTags.filter((tag) => tag.value !== undefined);
        return this.process.read({
            tags: prunedTags,
        });
    }
}
export class IOWriteable extends IOReadable {
    signer;
    constructor({ signer, ...config }) {
        if (Object.keys(config).length === 0) {
            super({
                process: new AOProcess({
                    processId: IO_TESTNET_PROCESS_ID,
                }),
            });
            this.signer = signer;
        }
        else if (isProcessConfiguration(config)) {
            super({ process: config.process });
            this.signer = signer;
        }
        else if (isProcessIdConfiguration(config)) {
            super({
                process: new AOProcess({
                    processId: config.processId,
                }),
            });
            this.signer = signer;
        }
        else {
            throw new InvalidContractConfigurationError();
        }
    }
    async transfer({ target, qty, }, options) {
        const { tags = [] } = options || {};
        return this.process.send({
            tags: [
                ...tags,
                { name: 'Action', value: 'Transfer' },
                {
                    name: 'Recipient',
                    value: target,
                },
                {
                    name: 'Quantity',
                    value: qty.valueOf().toString(),
                },
            ],
            signer: this.signer,
        });
    }
    async joinNetwork({ operatorStake, allowDelegatedStaking, delegateRewardShareRatio, fqdn, label, minDelegatedStake, note, port, properties, protocol, autoStake, observerAddress, }, options) {
        const { tags = [] } = options || {};
        const allTags = [
            ...tags,
            { name: 'Action', value: 'Join-Network' },
            {
                name: 'Operator-Stake',
                value: operatorStake.valueOf().toString(),
            },
            {
                name: 'Allow-Delegated-Staking',
                value: allowDelegatedStaking.toString(),
            },
            {
                name: 'Delegate-Reward-Share-Ratio',
                value: delegateRewardShareRatio.toString(),
            },
            {
                name: 'FQDN',
                value: fqdn,
            },
            {
                name: 'Label',
                value: label,
            },
            {
                name: 'Min-Delegated-Stake',
                value: minDelegatedStake.valueOf().toString(),
            },
            {
                name: 'Note',
                value: note,
            },
            {
                name: 'Port',
                value: port.toString(),
            },
            {
                name: 'Properties',
                value: properties,
            },
            {
                name: 'Protocol',
                value: protocol,
            },
            {
                name: 'Auto-Stake',
                value: autoStake.toString(),
            },
            {
                name: 'Observer-Address',
                value: observerAddress,
            },
        ];
        const prunedTags = allTags.filter((tag) => tag.value !== undefined);
        return this.process.send({
            signer: this.signer,
            tags: prunedTags,
        });
    }
    async leaveNetwork(options) {
        const { tags = [] } = options || {};
        return this.process.send({
            signer: this.signer,
            tags: [...tags, { name: 'Action', value: 'Leave-Network' }],
        });
    }
    async updateGatewaySettings({ allowDelegatedStaking, delegateRewardShareRatio, fqdn, label, minDelegatedStake, note, port, properties, protocol, autoStake, observerAddress, }, options) {
        const { tags = [] } = options || {};
        const allTags = [
            ...tags,
            { name: 'Action', value: 'Update-Gateway-Settings' },
            { name: 'Label', value: label },
            { name: 'Note', value: note },
            { name: 'FQDN', value: fqdn },
            { name: 'Port', value: port?.toString() },
            { name: 'Properties', value: properties },
            { name: 'Protocol', value: protocol },
            { name: 'Observer-Address', value: observerAddress },
            {
                name: 'Allow-Delegated-Staking',
                value: allowDelegatedStaking?.toString(),
            },
            {
                name: 'Delegate-Reward-Share-Ratio',
                value: delegateRewardShareRatio?.toString(),
            },
            {
                name: 'Min-Delegated-Stake',
                value: minDelegatedStake?.valueOf().toString(),
            },
            { name: 'Auto-Stake', value: autoStake?.toString() },
        ];
        const prunedTags = allTags.filter((tag) => tag.value !== undefined);
        return this.process.send({
            signer: this.signer,
            tags: prunedTags,
        });
    }
    async delegateStake(params, options) {
        const { tags = [] } = options || {};
        return this.process.send({
            signer: this.signer,
            tags: [
                ...tags,
                { name: 'Action', value: 'Delegate-Stake' },
                { name: 'Target', value: params.target },
                { name: 'Quantity', value: params.stakeQty.valueOf().toString() },
            ],
        });
    }
    async decreaseDelegateStake(params, options) {
        const { tags = [] } = options || {};
        return this.process.send({
            signer: this.signer,
            tags: [
                ...tags,
                { name: 'Action', value: 'Decrease-Delegate-Stake' },
                { name: 'Target', value: params.target },
                { name: 'Quantity', value: params.decreaseQty.valueOf().toString() },
            ],
        });
    }
    async increaseOperatorStake(params, options) {
        const { tags = [] } = options || {};
        return this.process.send({
            signer: this.signer,
            tags: [
                ...tags,
                { name: 'Action', value: 'Increase-Operator-Stake' },
                { name: 'Quantity', value: params.increaseQty.valueOf().toString() },
            ],
        });
    }
    async decreaseOperatorStake(params, options) {
        const { tags = [] } = options || {};
        return this.process.send({
            signer: this.signer,
            tags: [
                ...tags,
                { name: 'Action', value: 'Decrease-Operator-Stake' },
                { name: 'Quantity', value: params.decreaseQty.valueOf().toString() },
            ],
        });
    }
    async saveObservations(params, options) {
        const { tags = [] } = options || {};
        return this.process.send({
            signer: this.signer,
            tags: [
                ...tags,
                { name: 'Action', value: 'Save-Observations' },
                {
                    name: 'Report-Tx-Id',
                    value: params.reportTxId,
                },
                {
                    name: 'Failed-Gateways',
                    value: params.failedGateways.join(','),
                },
            ],
            data: {
                reportTxId: params.reportTxId,
                failedGateways: params.failedGateways,
            },
        });
    }
    async buyRecord(params, options) {
        const { tags = [] } = options || {};
        const allTags = [
            ...tags,
            { name: 'Action', value: 'Buy-Record' },
            { name: 'Name', value: params.name },
            { name: 'Years', value: params.years?.toString() ?? '1' },
            { name: 'Process-Id', value: params.processId },
            { name: 'Purchase-Type', value: params.type || 'lease' },
        ];
        const prunedTags = allTags.filter((tag) => tag.value !== undefined);
        return this.process.send({
            signer: this.signer,
            tags: prunedTags,
        });
    }
    async extendLease(params, options) {
        const { tags = [] } = options || {};
        return this.process.send({
            signer: this.signer,
            tags: [
                ...tags,
                { name: 'Action', value: 'Extend-Lease' },
                { name: 'Name', value: params.name },
                { name: 'Years', value: params.years.toString() },
            ],
        });
    }
    async increaseUndernameLimit(params, options) {
        const { tags = [] } = options || {};
        return this.process.send({
            signer: this.signer,
            tags: [
                ...tags,
                { name: 'Action', value: 'Increase-Undername-Limit' },
                { name: 'Name', value: params.name },
                { name: 'Quantity', value: params.increaseCount.toString() },
            ],
        });
    }
}

{"mappings":"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","sources":["packages/core/fs/src/index.js","packages/core/fs/src/NodeFS.browser.js","packages/core/fs/src/MemoryFS.js","packages/core/fs/package.json","node_modules/nullthrows/nullthrows.js","packages/core/fs/src/find.js","packages/core/fs/src/OverlayFS.js"],"sourcesContent":["// @flow strict-local\nimport type {FileSystem} from './types';\nimport type {FilePath} from '@parcel/types';\nimport type {Readable, Writable} from 'stream';\n\nimport path from 'path';\nimport stream from 'stream';\nimport {promisify} from 'util';\n\nexport type * from './types';\nexport * from './NodeFS';\nexport * from './MemoryFS';\nexport * from './OverlayFS';\n\nconst pipeline: (Readable, Writable) => Promise<void> = promisify(\n  stream.pipeline,\n);\n\n// Recursively copies a directory from the sourceFS to the destinationFS\nexport async function ncp(\n  sourceFS: FileSystem,\n  source: FilePath,\n  destinationFS: FileSystem,\n  destination: FilePath,\n) {\n  await destinationFS.mkdirp(destination);\n  let files = await sourceFS.readdir(source);\n  for (let file of files) {\n    let sourcePath = path.join(source, file);\n    let destPath = path.join(destination, file);\n    let stats = await sourceFS.stat(sourcePath);\n    if (stats.isFile()) {\n      await pipeline(\n        sourceFS.createReadStream(sourcePath),\n        destinationFS.createWriteStream(destPath),\n      );\n    } else if (stats.isDirectory()) {\n      await ncp(sourceFS, sourcePath, destinationFS, destPath);\n    }\n  }\n}\n","// @flow\nimport type {FileSystem} from './types';\n\n// $FlowFixMe[prop-missing] handled by the throwing constructor\nexport class NodeFS implements FileSystem {\n  constructor() {\n    throw new Error(\"NodeFS isn't available in the browser\");\n  }\n}\n","// @flow\n\nimport type {FileSystem, FileOptions, ReaddirOptions, Encoding} from './types';\nimport type {FilePath} from '@parcel/types';\nimport type {\n  Event,\n  Options as WatcherOptions,\n  AsyncSubscription,\n} from '@parcel/watcher';\n\nimport path from 'path';\nimport {Readable, Writable} from 'stream';\nimport {registerSerializableClass} from '@parcel/core';\nimport {SharedBuffer} from '@parcel/utils';\nimport packageJSON from '../package.json';\nimport WorkerFarm, {Handle} from '@parcel/workers';\nimport nullthrows from 'nullthrows';\nimport EventEmitter from 'events';\nimport {findAncestorFile, findNodeModule, findFirstFile} from './find';\n\nconst instances: Map<number, MemoryFS> = new Map();\nlet id = 0;\n\ntype HandleFunction = (...args: Array<any>) => any;\ntype SerializedMemoryFS = {\n  id: number,\n  handle: any,\n  dirs: Map<FilePath, Directory>,\n  files: Map<FilePath, File>,\n  symlinks: Map<FilePath, FilePath>,\n  ...\n};\n\ntype WorkerEvent = {|\n  type: 'writeFile' | 'unlink' | 'mkdir' | 'symlink',\n  path: FilePath,\n  entry?: Entry,\n  target?: FilePath,\n|};\n\ntype ResolveFunction = () => mixed;\n\nexport class MemoryFS implements FileSystem {\n  dirs: Map<FilePath, Directory>;\n  files: Map<FilePath, File>;\n  symlinks: Map<FilePath, FilePath>;\n  watchers: Map<FilePath, Set<Watcher>>;\n  events: Array<Event>;\n  id: number;\n  handle: Handle;\n  farm: WorkerFarm;\n  _cwd: FilePath;\n  _eventQueue: Array<Event>;\n  _watcherTimer: TimeoutID;\n  _numWorkerInstances: number = 0;\n  _workerHandles: Array<Handle>;\n  _workerRegisterResolves: Array<ResolveFunction> = [];\n  _emitter: EventEmitter = new EventEmitter();\n\n  constructor(workerFarm: WorkerFarm) {\n    this.farm = workerFarm;\n    this._cwd = path.resolve(path.sep);\n    this.dirs = new Map([[this._cwd, new Directory()]]);\n    this.files = new Map();\n    this.symlinks = new Map();\n    this.watchers = new Map();\n    this.events = [];\n    this.id = id++;\n    this._workerHandles = [];\n    this._eventQueue = [];\n    instances.set(this.id, this);\n    this._emitter.on('allWorkersRegistered', () => {\n      for (let resolve of this._workerRegisterResolves) {\n        resolve();\n      }\n      this._workerRegisterResolves = [];\n    });\n  }\n\n  static deserialize(opts: SerializedMemoryFS): MemoryFS | WorkerFS {\n    let existing = instances.get(opts.id);\n    if (existing != null) {\n      // Correct the count of worker instances since serialization assumes a new instance is created\n      WorkerFarm.getWorkerApi().runHandle(opts.handle, [\n        'decrementWorkerInstance',\n        [],\n      ]);\n      return existing;\n    }\n\n    let fs = new WorkerFS(opts.id, nullthrows(opts.handle));\n    fs.dirs = opts.dirs;\n    fs.files = opts.files;\n    fs.symlinks = opts.symlinks;\n    return fs;\n  }\n\n  serialize(): SerializedMemoryFS {\n    if (!this.handle) {\n      this.handle = this.farm.createReverseHandle(\n        (fn: string, args: Array<mixed>) => {\n          // $FlowFixMe\n          return this[fn](...args);\n        },\n      );\n    }\n\n    // If a worker instance already exists, it will decrement this number\n    this._numWorkerInstances++;\n\n    return {\n      $$raw: false,\n      id: this.id,\n      handle: this.handle,\n      dirs: this.dirs,\n      files: this.files,\n      symlinks: this.symlinks,\n    };\n  }\n\n  decrementWorkerInstance() {\n    this._numWorkerInstances--;\n    if (this._numWorkerInstances === this._workerHandles.length) {\n      this._emitter.emit('allWorkersRegistered');\n    }\n  }\n\n  cwd(): FilePath {\n    return this._cwd;\n  }\n\n  chdir(dir: FilePath) {\n    this._cwd = dir;\n  }\n\n  _normalizePath(filePath: FilePath, realpath: boolean = true): FilePath {\n    filePath = path.normalize(filePath);\n    if (!filePath.startsWith(this.cwd())) {\n      filePath = path.resolve(this.cwd(), filePath);\n    }\n\n    // get realpath by following symlinks\n    if (realpath) {\n      let {root, dir, base} = path.parse(filePath);\n      let parts = dir.slice(root.length).split(path.sep).concat(base);\n      let res = root;\n      for (let part of parts) {\n        res = path.join(res, part);\n        let symlink = this.symlinks.get(res);\n        if (symlink) {\n          res = symlink;\n        }\n      }\n\n      return res;\n    }\n\n    return filePath;\n  }\n\n  async writeFile(\n    filePath: FilePath,\n    contents: Buffer | string,\n    options?: ?FileOptions,\n  ) {\n    filePath = this._normalizePath(filePath);\n    if (this.dirs.has(filePath)) {\n      throw new FSError('EISDIR', filePath, 'is a directory');\n    }\n\n    let dir = path.dirname(filePath);\n    if (!this.dirs.has(dir)) {\n      throw new FSError('ENOENT', dir, 'does not exist');\n    }\n\n    let buffer = makeShared(contents);\n    let file = this.files.get(filePath);\n    let mode = (options && options.mode) || 0o666;\n    if (file) {\n      file.write(buffer, mode);\n      this.files.set(filePath, file);\n    } else {\n      this.files.set(filePath, new File(buffer, mode));\n    }\n\n    await this._sendWorkerEvent({\n      type: 'writeFile',\n      path: filePath,\n      entry: this.files.get(filePath),\n    });\n\n    this._triggerEvent({\n      type: file ? 'update' : 'create',\n      path: filePath,\n    });\n  }\n\n  // eslint-disable-next-line require-await\n  async readFile(filePath: FilePath, encoding?: Encoding): Promise<any> {\n    return this.readFileSync(filePath, encoding);\n  }\n\n  readFileSync(filePath: FilePath, encoding?: Encoding): any {\n    filePath = this._normalizePath(filePath);\n    let file = this.files.get(filePath);\n    if (file == null) {\n      throw new FSError('ENOENT', filePath, 'does not exist');\n    }\n\n    let buffer = file.read();\n    if (encoding) {\n      return buffer.toString(encoding);\n    }\n\n    return buffer;\n  }\n\n  async copyFile(source: FilePath, destination: FilePath) {\n    let contents = await this.readFile(source);\n    await this.writeFile(destination, contents);\n  }\n\n  statSync(filePath: FilePath): Stat {\n    filePath = this._normalizePath(filePath);\n\n    let dir = this.dirs.get(filePath);\n    if (dir) {\n      return dir.stat();\n    }\n\n    let file = this.files.get(filePath);\n    if (file == null) {\n      throw new FSError('ENOENT', filePath, 'does not exist');\n    }\n\n    return file.stat();\n  }\n\n  // eslint-disable-next-line require-await\n  async stat(filePath: FilePath): Promise<Stat> {\n    return this.statSync(filePath);\n  }\n\n  readdirSync(dir: FilePath, opts?: ReaddirOptions): any {\n    dir = this._normalizePath(dir);\n    if (!this.dirs.has(dir)) {\n      throw new FSError('ENOENT', dir, 'does not exist');\n    }\n\n    if (!dir.endsWith(path.sep)) {\n      dir += path.sep;\n    }\n\n    let res = [];\n    for (let [filePath, entry] of this.dirs) {\n      if (filePath === dir) {\n        continue;\n      }\n      if (\n        filePath.startsWith(dir) &&\n        filePath.indexOf(path.sep, dir.length) === -1\n      ) {\n        let name = filePath.slice(dir.length);\n        if (opts?.withFileTypes) {\n          res.push(new Dirent(name, entry));\n        } else {\n          res.push(name);\n        }\n      }\n    }\n\n    for (let [filePath, entry] of this.files) {\n      if (\n        filePath.startsWith(dir) &&\n        filePath.indexOf(path.sep, dir.length) === -1\n      ) {\n        let name = filePath.slice(dir.length);\n        if (opts?.withFileTypes) {\n          res.push(new Dirent(name, entry));\n        } else {\n          res.push(name);\n        }\n      }\n    }\n\n    for (let [from] of this.symlinks) {\n      if (from.startsWith(dir) && from.indexOf(path.sep, dir.length) === -1) {\n        let name = from.slice(dir.length);\n        if (opts?.withFileTypes) {\n          res.push(new Dirent(name, {mode: S_IFLNK}));\n        } else {\n          res.push(name);\n        }\n      }\n    }\n\n    return res;\n  }\n\n  // eslint-disable-next-line require-await\n  async readdir(dir: FilePath, opts?: ReaddirOptions): Promise<any> {\n    return this.readdirSync(dir, opts);\n  }\n\n  async unlink(filePath: FilePath): Promise<void> {\n    filePath = this._normalizePath(filePath);\n    if (!this.files.has(filePath) && !this.dirs.has(filePath)) {\n      throw new FSError('ENOENT', filePath, 'does not exist');\n    }\n\n    this.files.delete(filePath);\n    this.dirs.delete(filePath);\n    this.watchers.delete(filePath);\n\n    await this._sendWorkerEvent({\n      type: 'unlink',\n      path: filePath,\n    });\n\n    this._triggerEvent({\n      type: 'delete',\n      path: filePath,\n    });\n\n    return Promise.resolve();\n  }\n\n  async mkdirp(dir: FilePath): Promise<void> {\n    dir = this._normalizePath(dir);\n    if (this.dirs.has(dir)) {\n      return Promise.resolve();\n    }\n\n    if (this.files.has(dir)) {\n      throw new FSError('ENOENT', dir, 'is not a directory');\n    }\n\n    let root = path.parse(dir).root;\n    while (dir !== root) {\n      if (this.dirs.has(dir)) {\n        break;\n      }\n\n      this.dirs.set(dir, new Directory());\n      await this._sendWorkerEvent({\n        type: 'mkdir',\n        path: dir,\n      });\n\n      this._triggerEvent({\n        type: 'create',\n        path: dir,\n      });\n\n      dir = path.dirname(dir);\n    }\n\n    return Promise.resolve();\n  }\n\n  async rimraf(filePath: FilePath): Promise<void> {\n    filePath = this._normalizePath(filePath);\n\n    if (this.dirs.has(filePath)) {\n      let dir = filePath + path.sep;\n      for (let filePath of this.files.keys()) {\n        if (filePath.startsWith(dir)) {\n          this.files.delete(filePath);\n          await this._sendWorkerEvent({\n            type: 'unlink',\n            path: filePath,\n          });\n\n          this._triggerEvent({\n            type: 'delete',\n            path: filePath,\n          });\n        }\n      }\n\n      for (let dirPath of this.dirs.keys()) {\n        if (dirPath.startsWith(dir)) {\n          this.dirs.delete(dirPath);\n          this.watchers.delete(dirPath);\n          await this._sendWorkerEvent({\n            type: 'unlink',\n            path: filePath,\n          });\n\n          this._triggerEvent({\n            type: 'delete',\n            path: dirPath,\n          });\n        }\n      }\n\n      for (let filePath of this.symlinks.keys()) {\n        if (filePath.startsWith(dir)) {\n          this.symlinks.delete(filePath);\n          await this._sendWorkerEvent({\n            type: 'unlink',\n            path: filePath,\n          });\n        }\n      }\n\n      this.dirs.delete(filePath);\n      await this._sendWorkerEvent({\n        type: 'unlink',\n        path: filePath,\n      });\n\n      this._triggerEvent({\n        type: 'delete',\n        path: filePath,\n      });\n    } else if (this.files.has(filePath)) {\n      this.files.delete(filePath);\n      await this._sendWorkerEvent({\n        type: 'unlink',\n        path: filePath,\n      });\n\n      this._triggerEvent({\n        type: 'delete',\n        path: filePath,\n      });\n    }\n\n    return Promise.resolve();\n  }\n\n  async ncp(source: FilePath, destination: FilePath) {\n    source = this._normalizePath(source);\n\n    if (this.dirs.has(source)) {\n      if (!this.dirs.has(destination)) {\n        this.dirs.set(destination, new Directory());\n        await this._sendWorkerEvent({\n          type: 'mkdir',\n          path: destination,\n        });\n\n        this._triggerEvent({\n          type: 'create',\n          path: destination,\n        });\n      }\n\n      let dir = source + path.sep;\n      for (let dirPath of this.dirs.keys()) {\n        if (dirPath.startsWith(dir)) {\n          let destName = path.join(destination, dirPath.slice(dir.length));\n          if (!this.dirs.has(destName)) {\n            this.dirs.set(destName, new Directory());\n            await this._sendWorkerEvent({\n              type: 'mkdir',\n              path: destination,\n            });\n            this._triggerEvent({\n              type: 'create',\n              path: destName,\n            });\n          }\n        }\n      }\n\n      for (let [filePath, file] of this.files) {\n        if (filePath.startsWith(dir)) {\n          let destName = path.join(destination, filePath.slice(dir.length));\n          let exists = this.files.has(destName);\n          this.files.set(destName, file);\n          await this._sendWorkerEvent({\n            type: 'writeFile',\n            path: destName,\n            entry: file,\n          });\n\n          this._triggerEvent({\n            type: exists ? 'update' : 'create',\n            path: destName,\n          });\n        }\n      }\n    } else {\n      await this.copyFile(source, destination);\n    }\n  }\n\n  createReadStream(filePath: FilePath): ReadStream {\n    return new ReadStream(this, filePath);\n  }\n\n  createWriteStream(filePath: FilePath, options: ?FileOptions): WriteStream {\n    return new WriteStream(this, filePath, options);\n  }\n\n  realpathSync(filePath: FilePath): FilePath {\n    return this._normalizePath(filePath);\n  }\n\n  // eslint-disable-next-line require-await\n  async realpath(filePath: FilePath): Promise<FilePath> {\n    return this.realpathSync(filePath);\n  }\n\n  async symlink(target: FilePath, path: FilePath) {\n    target = this._normalizePath(target);\n    path = this._normalizePath(path);\n    this.symlinks.set(path, target);\n    await this._sendWorkerEvent({\n      type: 'symlink',\n      path,\n      target,\n    });\n  }\n\n  existsSync(filePath: FilePath): boolean {\n    filePath = this._normalizePath(filePath);\n    return this.files.has(filePath) || this.dirs.has(filePath);\n  }\n\n  // eslint-disable-next-line require-await\n  async exists(filePath: FilePath): Promise<boolean> {\n    return this.existsSync(filePath);\n  }\n\n  _triggerEvent(event: Event) {\n    this.events.push(event);\n    if (this.watchers.size === 0) {\n      return;\n    }\n\n    // Batch events\n    this._eventQueue.push(event);\n    clearTimeout(this._watcherTimer);\n\n    this._watcherTimer = setTimeout(() => {\n      let events = this._eventQueue;\n      this._eventQueue = [];\n\n      for (let [dir, watchers] of this.watchers) {\n        if (!dir.endsWith(path.sep)) {\n          dir += path.sep;\n        }\n\n        if (event.path.startsWith(dir)) {\n          for (let watcher of watchers) {\n            watcher.trigger(events);\n          }\n        }\n      }\n    }, 50);\n  }\n\n  _registerWorker(handle: Handle) {\n    this._workerHandles.push(handle);\n    if (this._numWorkerInstances === this._workerHandles.length) {\n      this._emitter.emit('allWorkersRegistered');\n    }\n  }\n\n  async _sendWorkerEvent(event: WorkerEvent) {\n    // Wait for worker instances to register their handles\n    while (this._workerHandles.length < this._numWorkerInstances) {\n      await new Promise(resolve => this._workerRegisterResolves.push(resolve));\n    }\n\n    await Promise.all(\n      this._workerHandles.map(workerHandle =>\n        this.farm.workerApi.runHandle(workerHandle, [event]),\n      ),\n    );\n  }\n\n  watch(\n    dir: FilePath,\n    fn: (err: ?Error, events: Array<Event>) => mixed,\n    opts: WatcherOptions,\n  ): Promise<AsyncSubscription> {\n    dir = this._normalizePath(dir);\n    let watcher = new Watcher(fn, opts);\n    let watchers = this.watchers.get(dir);\n    if (!watchers) {\n      watchers = new Set();\n      this.watchers.set(dir, watchers);\n    }\n\n    watchers.add(watcher);\n\n    return Promise.resolve({\n      unsubscribe: () => {\n        watchers = nullthrows(watchers);\n        watchers.delete(watcher);\n\n        if (watchers.size === 0) {\n          this.watchers.delete(dir);\n        }\n\n        return Promise.resolve();\n      },\n    });\n  }\n\n  async getEventsSince(\n    dir: FilePath,\n    snapshot: FilePath,\n    opts: WatcherOptions,\n  ): Promise<Array<Event>> {\n    let contents = await this.readFile(snapshot, 'utf8');\n    let len = Number(contents);\n    let events = this.events.slice(len);\n    let ignore = opts.ignore;\n    if (ignore) {\n      events = events.filter(\n        event => !ignore.some(i => event.path.startsWith(i + path.sep)),\n      );\n    }\n\n    return events;\n  }\n\n  async writeSnapshot(dir: FilePath, snapshot: FilePath): Promise<void> {\n    await this.writeFile(snapshot, '' + this.events.length);\n  }\n\n  findAncestorFile(\n    fileNames: Array<string>,\n    fromDir: FilePath,\n    root: FilePath,\n  ): ?FilePath {\n    return findAncestorFile(this, fileNames, fromDir, root);\n  }\n\n  findNodeModule(moduleName: string, fromDir: FilePath): ?FilePath {\n    return findNodeModule(this, moduleName, fromDir);\n  }\n\n  findFirstFile(filePaths: Array<FilePath>): ?FilePath {\n    return findFirstFile(this, filePaths);\n  }\n}\n\nclass Watcher {\n  fn: (err: ?Error, events: Array<Event>) => mixed;\n  options: WatcherOptions;\n\n  constructor(\n    fn: (err: ?Error, events: Array<Event>) => mixed,\n    options: WatcherOptions,\n  ) {\n    this.fn = fn;\n    this.options = options;\n  }\n\n  trigger(events: Array<Event>) {\n    let ignore = this.options.ignore;\n    if (ignore) {\n      events = events.filter(\n        event => !ignore.some(i => event.path.startsWith(i + path.sep)),\n      );\n    }\n\n    if (events.length > 0) {\n      this.fn(null, events);\n    }\n  }\n}\n\nexport class FSError extends Error {\n  code: string;\n  path: FilePath;\n  constructor(code: string, path: FilePath, message: string) {\n    super(`${code}: ${path} ${message}`);\n    this.name = 'FSError';\n    this.code = code;\n    this.path = path;\n    Error.captureStackTrace?.(this, this.constructor);\n  }\n}\n\nclass ReadStream extends Readable {\n  fs: FileSystem;\n  filePath: FilePath;\n  reading: boolean;\n  bytesRead: number;\n  constructor(fs: FileSystem, filePath: FilePath) {\n    super();\n    this.fs = fs;\n    this.filePath = filePath;\n    this.reading = false;\n    this.bytesRead = 0;\n  }\n\n  _read() {\n    if (this.reading) {\n      return;\n    }\n\n    this.reading = true;\n    this.fs.readFile(this.filePath).then(\n      res => {\n        this.bytesRead += res.byteLength;\n        this.push(res);\n        this.push(null);\n      },\n      err => {\n        this.emit('error', err);\n      },\n    );\n  }\n}\n\nclass WriteStream extends Writable {\n  fs: FileSystem;\n  filePath: FilePath;\n  options: ?FileOptions;\n  buffer: Buffer;\n\n  constructor(fs: FileSystem, filePath: FilePath, options: ?FileOptions) {\n    super({emitClose: true, autoDestroy: true});\n    this.fs = fs;\n    this.filePath = filePath;\n    this.options = options;\n    this.buffer = Buffer.alloc(0);\n  }\n\n  _write(\n    chunk: Buffer | string,\n    encoding: any,\n    callback: (error?: Error) => void,\n  ) {\n    let c = typeof chunk === 'string' ? Buffer.from(chunk, encoding) : chunk;\n    this.buffer = Buffer.concat([this.buffer, c]);\n    callback();\n  }\n\n  _final(callback: (error?: Error) => void) {\n    this.fs\n      .writeFile(this.filePath, this.buffer, this.options)\n      .then(callback)\n      .catch(callback);\n  }\n}\n\nconst S_IFREG = 0o100000;\nconst S_IFDIR = 0o040000;\nconst S_IFLNK = 0o120000;\nconst S_IFMT = 0o170000;\n\nclass Entry {\n  mode: number;\n  atime: number;\n  mtime: number;\n  ctime: number;\n  birthtime: number;\n  constructor(mode: number) {\n    this.mode = mode;\n    let now = Date.now();\n    this.atime = now;\n    this.mtime = now;\n    this.ctime = now;\n    this.birthtime = now;\n  }\n\n  access() {\n    let now = Date.now();\n    this.atime = now;\n    this.ctime = now;\n  }\n\n  modify(mode: number) {\n    let now = Date.now();\n    this.mtime = now;\n    this.ctime = now;\n    this.mode = mode;\n  }\n\n  getSize(): number {\n    return 0;\n  }\n\n  stat(): Stat {\n    return new Stat(this);\n  }\n}\n\nclass Stat {\n  dev: number = 0;\n  ino: number = 0;\n  mode: number;\n  nlink: number = 0;\n  uid: number = 0;\n  gid: number = 0;\n  rdev: number = 0;\n  size: number;\n  blksize: number = 0;\n  blocks: number = 0;\n  atimeMs: number;\n  mtimeMs: number;\n  ctimeMs: number;\n  birthtimeMs: number;\n  atime: Date;\n  mtime: Date;\n  ctime: Date;\n  birthtime: Date;\n\n  constructor(entry: Entry) {\n    this.mode = entry.mode;\n    this.size = entry.getSize();\n    this.atimeMs = entry.atime;\n    this.mtimeMs = entry.mtime;\n    this.ctimeMs = entry.ctime;\n    this.birthtimeMs = entry.birthtime;\n    this.atime = new Date(entry.atime);\n    this.mtime = new Date(entry.mtime);\n    this.ctime = new Date(entry.ctime);\n    this.birthtime = new Date(entry.birthtime);\n  }\n\n  isFile(): boolean {\n    return Boolean(this.mode & S_IFREG);\n  }\n\n  isDirectory(): boolean {\n    return Boolean(this.mode & S_IFDIR);\n  }\n\n  isBlockDevice(): boolean {\n    return false;\n  }\n\n  isCharacterDevice(): boolean {\n    return false;\n  }\n\n  isSymbolicLink(): boolean {\n    return false;\n  }\n\n  isFIFO(): boolean {\n    return false;\n  }\n\n  isSocket(): boolean {\n    return false;\n  }\n}\n\nclass Dirent {\n  name: string;\n  #mode: number;\n\n  constructor(name: string, entry: interface {mode: number}) {\n    this.name = name;\n    this.#mode = entry.mode;\n  }\n\n  isFile(): boolean {\n    return (this.#mode & S_IFMT) === S_IFREG;\n  }\n\n  isDirectory(): boolean {\n    return (this.#mode & S_IFMT) === S_IFDIR;\n  }\n\n  isBlockDevice(): boolean {\n    return false;\n  }\n\n  isCharacterDevice(): boolean {\n    return false;\n  }\n\n  isSymbolicLink(): boolean {\n    return (this.#mode & S_IFMT) === S_IFLNK;\n  }\n\n  isFIFO(): boolean {\n    return false;\n  }\n\n  isSocket(): boolean {\n    return false;\n  }\n}\n\nexport class File extends Entry {\n  buffer: Buffer;\n  constructor(buffer: Buffer, mode: number) {\n    super(S_IFREG | mode);\n    this.buffer = buffer;\n  }\n\n  read(): Buffer {\n    super.access();\n    return Buffer.from(this.buffer);\n  }\n\n  write(buffer: Buffer, mode: number) {\n    super.modify(S_IFREG | mode);\n    this.buffer = buffer;\n  }\n\n  getSize(): number {\n    return this.buffer.byteLength;\n  }\n}\n\nclass Directory extends Entry {\n  constructor() {\n    super(S_IFDIR);\n  }\n}\n\nexport function makeShared(contents: Buffer | string): Buffer {\n  if (typeof contents !== 'string' && contents.buffer instanceof SharedBuffer) {\n    return contents;\n  }\n\n  let contentsBuffer: Buffer | string = contents;\n  // $FlowFixMe\n  if (process.browser) {\n    // For the polyfilled buffer module, it's faster to always convert once so that the subsequent\n    // operations are fast (.byteLength and using .set instead of .write)\n    contentsBuffer =\n      contentsBuffer instanceof Buffer\n        ? contentsBuffer\n        : Buffer.from(contentsBuffer);\n  }\n\n  let length = Buffer.byteLength(contentsBuffer);\n  let shared = new SharedBuffer(length);\n  let buffer = Buffer.from(shared);\n  if (length > 0) {\n    if (typeof contentsBuffer === 'string') {\n      buffer.write(contentsBuffer);\n    } else {\n      buffer.set(contentsBuffer);\n    }\n  }\n\n  return buffer;\n}\n\nclass WorkerFS extends MemoryFS {\n  id: number;\n  handleFn: HandleFunction;\n\n  constructor(id: number, handle: Handle) {\n    // TODO Make this not a subclass\n    // $FlowFixMe\n    super();\n    this.id = id;\n    this.handleFn = (methodName, args) =>\n      WorkerFarm.getWorkerApi().runHandle(handle, [methodName, args]);\n\n    this.handleFn('_registerWorker', [\n      WorkerFarm.getWorkerApi().createReverseHandle(event => {\n        switch (event.type) {\n          case 'writeFile':\n            this.files.set(event.path, event.entry);\n            break;\n          case 'unlink':\n            this.files.delete(event.path);\n            this.dirs.delete(event.path);\n            this.symlinks.delete(event.path);\n            break;\n          case 'mkdir':\n            this.dirs.set(event.path, new Directory());\n            break;\n          case 'symlink':\n            this.symlinks.set(event.path, event.target);\n            break;\n        }\n      }),\n    ]);\n  }\n\n  static deserialize(opts: SerializedMemoryFS): MemoryFS {\n    return nullthrows(instances.get(opts.id));\n  }\n\n  serialize(): SerializedMemoryFS {\n    // $FlowFixMe\n    return {\n      id: this.id,\n    };\n  }\n\n  writeFile(\n    filePath: FilePath,\n    contents: Buffer | string,\n    options: ?FileOptions,\n  ): Promise<void> {\n    super.writeFile(filePath, contents, options);\n    let buffer = makeShared(contents);\n    return this.handleFn('writeFile', [filePath, buffer, options]);\n  }\n\n  unlink(filePath: FilePath): Promise<void> {\n    super.unlink(filePath);\n    return this.handleFn('unlink', [filePath]);\n  }\n\n  mkdirp(dir: FilePath): Promise<void> {\n    super.mkdirp(dir);\n    return this.handleFn('mkdirp', [dir]);\n  }\n\n  rimraf(filePath: FilePath): Promise<void> {\n    super.rimraf(filePath);\n    return this.handleFn('rimraf', [filePath]);\n  }\n\n  ncp(source: FilePath, destination: FilePath): Promise<void> {\n    super.ncp(source, destination);\n    return this.handleFn('ncp', [source, destination]);\n  }\n\n  symlink(target: FilePath, path: FilePath): Promise<void> {\n    super.symlink(target, path);\n    return this.handleFn('symlink', [target, path]);\n  }\n}\n\nregisterSerializableClass(`${packageJSON.version}:MemoryFS`, MemoryFS);\nregisterSerializableClass(`${packageJSON.version}:WorkerFS`, WorkerFS);\nregisterSerializableClass(`${packageJSON.version}:Stat`, Stat);\nregisterSerializableClass(`${packageJSON.version}:File`, File);\nregisterSerializableClass(`${packageJSON.version}:Directory`, Directory);\n","{\n  \"name\": \"@parcel/fs\",\n  \"version\": \"2.12.0\",\n  \"description\": \"Blazing fast, zero configuration web application bundler\",\n  \"license\": \"MIT\",\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"funding\": {\n    \"type\": \"opencollective\",\n    \"url\": \"https://opencollective.com/parcel\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/parcel-bundler/parcel.git\"\n  },\n  \"main\": \"lib/index.js\",\n  \"source\": \"src/index.js\",\n  \"types\": \"index.d.ts\",\n  \"engines\": {\n    \"node\": \">= 12.0.0\"\n  },\n  \"targets\": {\n    \"types\": false,\n    \"main\": {\n      \"includeNodeModules\": {\n        \"@parcel/core\": false,\n        \"@parcel/rust\": false,\n        \"@parcel/types\": false,\n        \"@parcel/utils\": false,\n        \"@parcel/watcher\": false,\n        \"@parcel/workers\": false\n      }\n    },\n    \"browser\": {\n      \"includeNodeModules\": {\n        \"@parcel/core\": false,\n        \"@parcel/rust\": false,\n        \"@parcel/types\": false,\n        \"@parcel/utils\": false,\n        \"@parcel/watcher\": false,\n        \"@parcel/workers\": false\n      }\n    }\n  },\n  \"scripts\": {\n    \"build-ts\": \"mkdir -p lib && flow-to-ts src/types.js > lib/types.d.ts\",\n    \"check-ts\": \"tsc --noEmit index.d.ts\"\n  },\n  \"dependencies\": {\n    \"@parcel/rust\": \"2.12.0\",\n    \"@parcel/types\": \"2.12.0\",\n    \"@parcel/utils\": \"2.12.0\",\n    \"@parcel/watcher\": \"^2.0.7\",\n    \"@parcel/workers\": \"2.12.0\"\n  },\n  \"devDependencies\": {\n    \"graceful-fs\": \"^4.2.4\",\n    \"ncp\": \"^2.0.0\",\n    \"nullthrows\": \"^1.1.1\",\n    \"utility-types\": \"^3.10.0\"\n  },\n  \"peerDependencies\": {\n    \"@parcel/core\": \"^2.12.0\"\n  },\n  \"browser\": {\n    \"@parcel/fs\": \"./lib/browser.js\",\n    \"./src/NodeFS.js\": \"./src/NodeFS.browser.js\"\n  },\n  \"gitHead\": \"2059029ee91e5f03a273b0954d3e629d7375f986\"\n}\n","'use strict';\n\nfunction nullthrows(x, message) {\n  if (x != null) {\n    return x;\n  }\n  var error = new Error(message !== undefined ? message : 'Got unexpected ' + x);\n  error.framesToPop = 1; // Skip nullthrows's own stack frame.\n  throw error;\n}\n\nmodule.exports = nullthrows;\nmodule.exports.default = nullthrows;\n\nObject.defineProperty(module.exports, '__esModule', {value: true});\n","// @flow\nimport type {FilePath} from '@parcel/types';\nimport type {FileSystem} from './types';\nimport path from 'path';\n\nexport function findNodeModule(\n  fs: FileSystem,\n  moduleName: string,\n  dir: FilePath,\n): ?FilePath {\n  let {root} = path.parse(dir);\n  while (dir !== root) {\n    // Skip node_modules directories\n    if (path.basename(dir) === 'node_modules') {\n      dir = path.dirname(dir);\n    }\n\n    try {\n      let moduleDir = path.join(dir, 'node_modules', moduleName);\n      let stats = fs.statSync(moduleDir);\n      if (stats.isDirectory()) {\n        return moduleDir;\n      }\n    } catch (err) {\n      // ignore\n    }\n\n    // Move up a directory\n    dir = path.dirname(dir);\n  }\n\n  return null;\n}\n\nexport function findAncestorFile(\n  fs: FileSystem,\n  fileNames: Array<string>,\n  dir: FilePath,\n  root: FilePath,\n): ?FilePath {\n  let {root: pathRoot} = path.parse(dir);\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (path.basename(dir) === 'node_modules') {\n      return null;\n    }\n\n    for (const fileName of fileNames) {\n      let filePath = path.join(dir, fileName);\n      try {\n        if (fs.statSync(filePath).isFile()) {\n          return filePath;\n        }\n      } catch (err) {\n        // ignore\n      }\n    }\n\n    if (dir === root || dir === pathRoot) {\n      break;\n    }\n\n    dir = path.dirname(dir);\n  }\n\n  return null;\n}\n\nexport function findFirstFile(\n  fs: FileSystem,\n  filePaths: Array<FilePath>,\n): ?FilePath {\n  for (let filePath of filePaths) {\n    try {\n      if (fs.statSync(filePath).isFile()) {\n        return filePath;\n      }\n    } catch (err) {\n      // ignore\n    }\n  }\n}\n","// @flow\n\nimport type {Readable, Writable} from 'stream';\nimport type {\n  Encoding,\n  FileOptions,\n  FileSystem,\n  ReaddirOptions,\n  Stats,\n} from './types';\nimport type {FilePath} from '@parcel/types';\nimport type {\n  Event,\n  Options as WatcherOptions,\n  AsyncSubscription,\n} from '@parcel/watcher';\n\nimport {registerSerializableClass} from '@parcel/core';\nimport WorkerFarm from '@parcel/workers';\nimport packageJSON from '../package.json';\nimport {findAncestorFile, findNodeModule, findFirstFile} from './find';\nimport {MemoryFS} from './MemoryFS';\n\nimport nullthrows from 'nullthrows';\nimport path from 'path';\n\nexport class OverlayFS implements FileSystem {\n  deleted: Set<FilePath> = new Set();\n  writable: FileSystem;\n  readable: FileSystem;\n  _cwd: FilePath;\n\n  constructor(workerFarmOrFS: WorkerFarm | FileSystem, readable: FileSystem) {\n    if (workerFarmOrFS instanceof WorkerFarm) {\n      this.writable = new MemoryFS(workerFarmOrFS);\n    } else {\n      this.writable = workerFarmOrFS;\n    }\n    this.readable = readable;\n    this._cwd = readable.cwd();\n  }\n\n  static deserialize(opts: any): OverlayFS {\n    let fs = new OverlayFS(opts.writable, opts.readable);\n    if (opts.deleted != null) fs.deleted = opts.deleted;\n    return fs;\n  }\n\n  serialize(): {|\n    $$raw: boolean,\n    readable: FileSystem,\n    writable: FileSystem,\n    deleted: Set<FilePath>,\n  |} {\n    return {\n      $$raw: false,\n      writable: this.writable,\n      readable: this.readable,\n      deleted: this.deleted,\n    };\n  }\n\n  _deletedThrows(filePath: FilePath): FilePath {\n    filePath = this._normalizePath(filePath);\n    if (this.deleted.has(filePath)) {\n      throw new FSError('ENOENT', filePath, 'does not exist');\n    }\n    return filePath;\n  }\n\n  _checkExists(filePath: FilePath): FilePath {\n    filePath = this._deletedThrows(filePath);\n    if (!this.existsSync(filePath)) {\n      throw new FSError('ENOENT', filePath, 'does not exist');\n    }\n    return filePath;\n  }\n\n  _isSymlink(filePath: FilePath): boolean {\n    filePath = this._normalizePath(filePath);\n    // Check the parts of the path to see if any are symlinks.\n    let {root, dir, base} = path.parse(filePath);\n    let segments = dir.slice(root.length).split(path.sep).concat(base);\n    while (segments.length) {\n      filePath = path.join(root, ...segments);\n      let name = segments.pop();\n      if (this.deleted.has(filePath)) {\n        return false;\n      } else if (\n        this.writable instanceof MemoryFS &&\n        this.writable.symlinks.has(filePath)\n      ) {\n        return true;\n      } else {\n        // HACK: Parcel fs does not provide `lstatSync`,\n        // so we use `readdirSync` to check if the path is a symlink.\n        let parent = path.resolve(filePath, '..');\n        if (parent === filePath) {\n          return false;\n        }\n        try {\n          for (let dirent of this.readdirSync(parent, {withFileTypes: true})) {\n            if (typeof dirent === 'string') {\n              break; // {withFileTypes: true} not supported\n            } else if (dirent.name === name) {\n              if (dirent.isSymbolicLink()) {\n                return true;\n              }\n            }\n          }\n        } catch (e) {\n          if (e.code === 'ENOENT') {\n            return false;\n          }\n          throw e;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  async _copyPathForWrite(filePath: FilePath): Promise<FilePath> {\n    filePath = await this._normalizePath(filePath);\n    let dirPath = path.dirname(filePath);\n    if (this.existsSync(dirPath) && !this.writable.existsSync(dirPath)) {\n      await this.writable.mkdirp(dirPath);\n    }\n    return filePath;\n  }\n\n  _normalizePath(filePath: FilePath): FilePath {\n    return path.resolve(this.cwd(), filePath);\n  }\n\n  // eslint-disable-next-line require-await\n  async readFile(filePath: FilePath, encoding?: Encoding): Promise<any> {\n    return this.readFileSync(filePath, encoding);\n  }\n\n  async writeFile(\n    filePath: FilePath,\n    contents: string | Buffer,\n    options: ?FileOptions,\n  ): Promise<void> {\n    filePath = await this._copyPathForWrite(filePath);\n    await this.writable.writeFile(filePath, contents, options);\n    this.deleted.delete(filePath);\n  }\n\n  async copyFile(source: FilePath, destination: FilePath): Promise<void> {\n    source = this._normalizePath(source);\n    destination = await this._copyPathForWrite(destination);\n\n    if (await this.writable.exists(source)) {\n      await this.writable.writeFile(\n        destination,\n        await this.writable.readFile(source),\n      );\n    } else {\n      await this.writable.writeFile(\n        destination,\n        await this.readable.readFile(source),\n      );\n    }\n\n    this.deleted.delete(destination);\n  }\n\n  // eslint-disable-next-line require-await\n  async stat(filePath: FilePath): Promise<Stats> {\n    return this.statSync(filePath);\n  }\n\n  async symlink(target: FilePath, filePath: FilePath): Promise<void> {\n    target = this._normalizePath(target);\n    filePath = this._normalizePath(filePath);\n    await this.writable.symlink(target, filePath);\n    this.deleted.delete(filePath);\n  }\n\n  async unlink(filePath: FilePath): Promise<void> {\n    filePath = this._normalizePath(filePath);\n\n    let toDelete = [filePath];\n\n    if (this.writable instanceof MemoryFS && this._isSymlink(filePath)) {\n      this.writable.symlinks.delete(filePath);\n    } else if (this.statSync(filePath).isDirectory()) {\n      let stack = [filePath];\n\n      // Recursively add every descendant path to deleted.\n      while (stack.length) {\n        let root = nullthrows(stack.pop());\n        for (let ent of this.readdirSync(root, {withFileTypes: true})) {\n          if (typeof ent === 'string') {\n            let childPath = path.join(root, ent);\n            toDelete.push(childPath);\n            if (this.statSync(childPath).isDirectory()) {\n              stack.push(childPath);\n            }\n          } else {\n            let childPath = path.join(root, ent.name);\n            toDelete.push(childPath);\n            if (ent.isDirectory()) {\n              stack.push(childPath);\n            }\n          }\n        }\n      }\n    }\n\n    try {\n      await this.writable.unlink(filePath);\n    } catch (e) {\n      if (e.code === 'ENOENT' && !this.readable.existsSync(filePath)) {\n        throw e;\n      }\n    }\n\n    for (let pathToDelete of toDelete) {\n      this.deleted.add(pathToDelete);\n    }\n  }\n\n  async mkdirp(dir: FilePath): Promise<void> {\n    dir = this._normalizePath(dir);\n    await this.writable.mkdirp(dir);\n\n    if (this.deleted != null) {\n      let root = path.parse(dir).root;\n      while (dir !== root) {\n        this.deleted.delete(dir);\n        dir = path.dirname(dir);\n      }\n    }\n  }\n\n  async rimraf(filePath: FilePath): Promise<void> {\n    try {\n      await this.unlink(filePath);\n    } catch (e) {\n      // noop\n    }\n  }\n\n  // eslint-disable-next-line require-await\n  async ncp(source: FilePath, destination: FilePath): Promise<void> {\n    // TODO: Implement this correctly.\n    return this.writable.ncp(source, destination);\n  }\n\n  createReadStream(filePath: FilePath, opts?: ?FileOptions): Readable {\n    filePath = this._deletedThrows(filePath);\n    if (this.writable.existsSync(filePath)) {\n      return this.writable.createReadStream(filePath, opts);\n    }\n\n    return this.readable.createReadStream(filePath, opts);\n  }\n\n  createWriteStream(path: FilePath, opts?: ?FileOptions): Writable {\n    path = this._normalizePath(path);\n    this.deleted.delete(path);\n    return this.writable.createWriteStream(path, opts);\n  }\n\n  cwd(): FilePath {\n    return this._cwd;\n  }\n\n  chdir(path: FilePath): void {\n    this._cwd = this._checkExists(path);\n  }\n\n  // eslint-disable-next-line require-await\n  async realpath(filePath: FilePath): Promise<FilePath> {\n    return this.realpathSync(filePath);\n  }\n\n  readFileSync(filePath: FilePath, encoding?: Encoding): any {\n    filePath = this.realpathSync(filePath);\n    try {\n      // $FlowFixMe[incompatible-call]\n      return this.writable.readFileSync(filePath, encoding);\n    } catch (err) {\n      // $FlowFixMe[incompatible-call]\n      return this.readable.readFileSync(filePath, encoding);\n    }\n  }\n\n  statSync(filePath: FilePath): Stats {\n    filePath = this._normalizePath(filePath);\n    try {\n      return this.writable.statSync(filePath);\n    } catch (e) {\n      if (e.code === 'ENOENT' && this.existsSync(filePath)) {\n        return this.readable.statSync(filePath);\n      }\n      throw e;\n    }\n  }\n\n  realpathSync(filePath: FilePath): FilePath {\n    filePath = this._deletedThrows(filePath);\n    filePath = this._deletedThrows(this.writable.realpathSync(filePath));\n    if (!this.writable.existsSync(filePath)) {\n      return this.readable.realpathSync(filePath);\n    }\n    return filePath;\n  }\n\n  // eslint-disable-next-line require-await\n  async exists(filePath: FilePath): Promise<boolean> {\n    return this.existsSync(filePath);\n  }\n\n  existsSync(filePath: FilePath): boolean {\n    filePath = this._normalizePath(filePath);\n    if (this.deleted.has(filePath)) return false;\n\n    try {\n      filePath = this.realpathSync(filePath);\n    } catch (err) {\n      if (err.code !== 'ENOENT') throw err;\n    }\n\n    if (this.deleted.has(filePath)) return false;\n\n    return (\n      this.writable.existsSync(filePath) || this.readable.existsSync(filePath)\n    );\n  }\n\n  // eslint-disable-next-line require-await\n  async readdir(path: FilePath, opts?: ReaddirOptions): Promise<any> {\n    return this.readdirSync(path, opts);\n  }\n\n  readdirSync(dir: FilePath, opts?: ReaddirOptions): any {\n    dir = this.realpathSync(dir);\n    // Read from both filesystems and merge the results\n    let entries = new Map();\n\n    try {\n      for (let entry: any of this.writable.readdirSync(dir, opts)) {\n        let filePath = path.join(dir, entry.name ?? entry);\n        if (this.deleted.has(filePath)) continue;\n        entries.set(filePath, entry);\n      }\n    } catch {\n      // noop\n    }\n\n    try {\n      for (let entry: any of this.readable.readdirSync(dir, opts)) {\n        let filePath = path.join(dir, entry.name ?? entry);\n        if (this.deleted.has(filePath)) continue;\n        if (entries.has(filePath)) continue;\n        entries.set(filePath, entry);\n      }\n    } catch {\n      // noop\n    }\n\n    return Array.from(entries.values());\n  }\n\n  async watch(\n    dir: FilePath,\n    fn: (err: ?Error, events: Array<Event>) => mixed,\n    opts: WatcherOptions,\n  ): Promise<AsyncSubscription> {\n    let writableSubscription = await this.writable.watch(dir, fn, opts);\n    let readableSubscription = await this.readable.watch(dir, fn, opts);\n    return {\n      unsubscribe: async () => {\n        await writableSubscription.unsubscribe();\n        await readableSubscription.unsubscribe();\n      },\n    };\n  }\n\n  async getEventsSince(\n    dir: FilePath,\n    snapshot: FilePath,\n    opts: WatcherOptions,\n  ): Promise<Array<Event>> {\n    let writableEvents = await this.writable.getEventsSince(\n      dir,\n      snapshot,\n      opts,\n    );\n    let readableEvents = await this.readable.getEventsSince(\n      dir,\n      snapshot,\n      opts,\n    );\n    return [...writableEvents, ...readableEvents];\n  }\n\n  async writeSnapshot(\n    dir: FilePath,\n    snapshot: FilePath,\n    opts: WatcherOptions,\n  ): Promise<void> {\n    await this.writable.writeSnapshot(dir, snapshot, opts);\n  }\n\n  findAncestorFile(\n    fileNames: Array<string>,\n    fromDir: FilePath,\n    root: FilePath,\n  ): ?FilePath {\n    return findAncestorFile(this, fileNames, fromDir, root);\n  }\n\n  findNodeModule(moduleName: string, fromDir: FilePath): ?FilePath {\n    return findNodeModule(this, moduleName, fromDir);\n  }\n\n  findFirstFile(filePaths: Array<FilePath>): ?FilePath {\n    return findFirstFile(this, filePaths);\n  }\n}\n\nclass FSError extends Error {\n  code: string;\n  path: FilePath;\n  constructor(code: string, path: FilePath, message: string) {\n    super(`${code}: ${path} ${message}`);\n    this.name = 'FSError';\n    this.code = code;\n    this.path = path;\n    Error.captureStackTrace?.(this, this.constructor);\n  }\n}\n\nregisterSerializableClass(`${packageJSON.version}:OverlayFS`, OverlayFS);\n"],"names":["path","stream","promisify","pipeline","ncp","sourceFS","source","destinationFS","destination","mkdirp","files","readdir","file","sourcePath","join","destPath","stats","stat","isFile","createReadStream","createWriteStream","isDirectory","NodeFS","constructor","Error","Readable","Writable","registerSerializableClass","SharedBuffer","packageJSON","WorkerFarm","Handle","nullthrows","EventEmitter","findAncestorFile","findNodeModule","findFirstFile","instances","Map","id","MemoryFS","_numWorkerInstances","_workerRegisterResolves","_emitter","workerFarm","farm","_cwd","resolve","sep","dirs","Directory","symlinks","watchers","events","_workerHandles","_eventQueue","set","on","deserialize","opts","existing","get","getWorkerApi","runHandle","handle","fs","WorkerFS","serialize","createReverseHandle","fn","args","$$raw","decrementWorkerInstance","length","emit","cwd","chdir","dir","_normalizePath","filePath","realpath","normalize","startsWith","root","base","parse","parts","slice","split","concat","res","part","symlink","writeFile","contents","options","has","FSError","dirname","buffer","makeShared","mode","write","File","_sendWorkerEvent","type","entry","_triggerEvent","readFile","encoding","readFileSync","read","toString","copyFile","statSync","readdirSync","endsWith","indexOf","name","withFileTypes","push","Dirent","from","S_IFLNK","unlink","delete","Promise","rimraf","keys","dirPath","destName","exists","ReadStream","WriteStream","realpathSync","target","existsSync","event","size","clearTimeout","_watcherTimer","setTimeout","watcher","trigger","_registerWorker","all","map","workerHandle","workerApi","watch","Watcher","Set","add","unsubscribe","getEventsSince","snapshot","len","Number","ignore","filter","some","i","writeSnapshot","fileNames","fromDir","moduleName","filePaths","code","message","captureStackTrace","reading","bytesRead","_read","then","byteLength","err","emitClose","autoDestroy","Buffer","alloc","_write","chunk","callback","c","_final","catch","S_IFREG","S_IFDIR","S_IFMT","Entry","now","Date","atime","mtime","ctime","birthtime","access","modify","getSize","Stat","dev","ino","nlink","uid","gid","rdev","blksize","blocks","atimeMs","mtimeMs","ctimeMs","birthtimeMs","Boolean","isBlockDevice","isCharacterDevice","isSymbolicLink","isFIFO","isSocket","contentsBuffer","process","browser","shared","handleFn","methodName","version","module","exports","JSON","basename","moduleDir","pathRoot","fileName","OverlayFS","deleted","workerFarmOrFS","readable","writable","_deletedThrows","_checkExists","_isSymlink","segments","pop","parent","dirent","e","_copyPathForWrite","toDelete","stack","ent","childPath","pathToDelete","entries","Array","values","writableSubscription","readableSubscription","writableEvents","readableEvents"],"version":3,"file":"browser.js.map"}
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.report = report;
exports.reportWorker = reportWorker;
function _assert() {
  const data = _interopRequireDefault(require("assert"));
  _assert = function () {
    return data;
  };
  return data;
}
var _Bundle = require("./public/Bundle");
function _workers() {
  const data = _interopRequireWildcard(require("@parcel/workers"));
  _workers = function () {
    return data;
  };
  return data;
}
var _ParcelConfig = _interopRequireDefault(require("./ParcelConfig"));
function _logger() {
  const data = _interopRequireWildcard(require("@parcel/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
var _PluginOptions = _interopRequireDefault(require("./public/PluginOptions"));
var _BundleGraph = _interopRequireDefault(require("./BundleGraph"));
function _profiler() {
  const data = require("@parcel/profiler");
  _profiler = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const instances = new Set();
class ReporterRunner {
  constructor(opts) {
    this.config = opts.config;
    this.options = opts.options;
    this.workerFarm = opts.workerFarm;
    this.pluginOptions = new _PluginOptions.default(this.options);
    _logger().default.onLog(event => this.report(event));
    _profiler().tracer.onTrace(event => this.report(event));
    _workers().bus.on('reporterEvent', this.eventHandler);
    instances.add(this);
    if (this.options.shouldPatchConsole) {
      (0, _logger().patchConsole)();
    } else {
      (0, _logger().unpatchConsole)();
    }
  }
  eventHandler = event => {
    if (event.type === 'buildProgress' && (event.phase === 'optimizing' || event.phase === 'packaging') && !(event.bundle instanceof _Bundle.NamedBundle)) {
      // $FlowFixMe[prop-missing]
      let bundleGraphRef = event.bundleGraphRef;
      // $FlowFixMe[incompatible-exact]
      let bundle = event.bundle;
      // Convert any internal bundles back to their public equivalents as reporting
      // is public api
      let bundleGraph = this.workerFarm.workerApi.getSharedReference(
      // $FlowFixMe
      bundleGraphRef);
      (0, _assert().default)(bundleGraph instanceof _BundleGraph.default);
      // $FlowFixMe[incompatible-call]
      this.report({
        ...event,
        bundle: _Bundle.NamedBundle.get(bundle, bundleGraph, this.options)
      });
      return;
    }
    this.report(event);
  };
  async report(event) {
    // We should catch all errors originating from reporter plugins to prevent infinite loops
    try {
      let reporters = this.reporters;
      if (!reporters) {
        this.reporters = await this.config.getReporters();
        reporters = this.reporters;
      }
      for (let reporter of this.reporters) {
        let measurement;
        try {
          // To avoid an infinite loop we don't measure trace events, as they'll
          // result in another trace!
          if (event.type !== 'trace') {
            measurement = _profiler().tracer.createMeasurement(reporter.name, 'reporter');
          }
          await reporter.plugin.report({
            event,
            options: this.pluginOptions,
            logger: new (_logger().PluginLogger)({
              origin: reporter.name
            }),
            tracer: new (_profiler().PluginTracer)({
              origin: reporter.name,
              category: 'reporter'
            })
          });
        } catch (reportError) {
          _logger().INTERNAL_ORIGINAL_CONSOLE.error(reportError);
        } finally {
          measurement && measurement.end();
        }
      }
    } catch (err) {
      _logger().INTERNAL_ORIGINAL_CONSOLE.error(err);
    }
  }
  dispose() {
    _workers().bus.off('reporterEvent', this.eventHandler);
    instances.delete(this);
  }
}
exports.default = ReporterRunner;
function reportWorker(workerApi, event) {
  if (event.type === 'buildProgress' && (event.phase === 'optimizing' || event.phase === 'packaging')) {
    // Convert any public api bundles to their internal equivalents for
    // easy serialization
    _workers().bus.emit('reporterEvent', {
      ...event,
      bundle: (0, _Bundle.bundleToInternalBundle)(event.bundle),
      bundleGraphRef: workerApi.resolveSharedReference((0, _Bundle.bundleToInternalBundleGraph)(event.bundle))
    });
    return;
  }
  _workers().bus.emit('reporterEvent', event);
}
async function report(event) {
  await Promise.all([...instances].map(instance => instance.report(event)));
}
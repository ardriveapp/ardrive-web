/// <reference types="node" />
import ServiceClient from './v2/serviceClient';
import * as txn from '../transaction';
import { CustomTokenHeader, KMDTokenHeader } from './urlTokenBaseHTTPClient';
export default class Kmd extends ServiceClient {
    constructor(token: string | KMDTokenHeader | CustomTokenHeader, baseServer?: string, port?: string | number, headers?: {});
    /**
     * version returns a VersionResponse containing a list of kmd API versions supported by this running kmd instance.
     */
    versions(): Promise<any>;
    /**
     * listWallets returns a ListWalletsResponse containing the list of wallets known to kmd. Using a wallet ID
     * returned from this endpoint, you can initialize a wallet handle with client.InitWalletHandle
     */
    listWallets(): Promise<any>;
    /**
     * createWallet creates a wallet with the specified name, password, driver,
     * and master derivation key. If the master derivation key is blank, one is
     * generated internally to kmd. CreateWallet returns a CreateWalletResponse
     * containing information about the new wallet.
     * @param walletName
     * @param walletPassword
     * @param walletDriverName
     * @param walletMDK
     */
    createWallet(walletName: string, walletPassword: string, walletMDK?: Uint8Array, walletDriverName?: string): Promise<any>;
    /**
     * initWalletHandle accepts a wallet ID and a wallet password, and returns an
     * initWalletHandleResponse containing a wallet handle token. This wallet
     * handle token can be used for subsequent operations on this wallet, like key
     * generation, transaction signing, etc.. WalletHandleTokens expire after a
     * configurable number of seconds, and must be renewed periodically with
     * RenewWalletHandle. It is good practice to call ReleaseWalletHandle when
     * you're done interacting with this wallet.
     * @param walletID
     * @param walletPassword
     */
    initWalletHandle(walletID: string, walletPassword: string): Promise<any>;
    /**
     * releaseWalletHandle invalidates the passed wallet handle token, making
     * it unusuable for subsequent wallet operations.
     * @param walletHandle
     */
    releaseWalletHandle(walletHandle: string): Promise<any>;
    /**
     * renewWalletHandle accepts a wallet handle and attempts to renew it, moving
     * the expiration time to some number of seconds in the future. It returns a
     * RenewWalletHandleResponse containing the walletHandle and the number of
     * seconds until expiration
     * @param walletHandle
     */
    renewWalletHandle(walletHandle: string): Promise<any>;
    /**
     * renameWallet accepts a wallet ID, wallet password, and a new wallet name,
     * and renames the underlying wallet.
     * @param walletID
     * @param walletPassword
     * @param newWalletName
     */
    renameWallet(walletID: string, walletPassword: string, newWalletName: string): Promise<any>;
    /**
     * getWallet accepts a wallet handle and returns high level information about
     * this wallet in a GetWalletResponse.
     * @param walletHandle
     */
    getWallet(walletHandle: string): Promise<any>;
    /**
     * exportMasterDerivationKey accepts a wallet handle and a wallet password, and
     * returns an ExportMasterDerivationKeyResponse containing the master
     * derivation key. This key can be used as an argument to CreateWallet in
     * order to recover the keys generated by this wallet. The master derivation
     * key can be encoded as a sequence of words using the mnemonic library, and
     * @param walletHandle
     * @param walletPassword
     */
    exportMasterDerivationKey(walletHandle: string, walletPassword: string): Promise<{
        master_derivation_key: Buffer;
    }>;
    /**
     * importKey accepts a wallet handle and an ed25519 private key, and imports
     * the key into the wallet. It returns an ImportKeyResponse containing the
     * address corresponding to this private key.
     * @param walletHandle
     * @param secretKey
     */
    importKey(walletHandle: string, secretKey: Uint8Array): Promise<any>;
    /**
     * exportKey accepts a wallet handle, wallet password, and address, and returns
     * an ExportKeyResponse containing the ed25519 private key corresponding to the
     * address stored in the wallet.
     * @param walletHandle
     * @param walletPassword
     * @param addr
     */
    exportKey(walletHandle: string, walletPassword: string, addr: string): Promise<{
        private_key: Buffer;
    }>;
    /**
     * generateKey accepts a wallet handle, and then generates the next key in the
     * wallet using its internal master derivation key. Two wallets with the same
     * master derivation key will generate the same sequence of keys.
     * @param walletHandle
     */
    generateKey(walletHandle: string): Promise<any>;
    /**
     * deleteKey accepts a wallet handle, wallet password, and address, and deletes
     * the information about this address from the wallet (including address and
     * secret key). If DeleteKey is called on a key generated using GenerateKey,
     * the same key will not be generated again. However, if a wallet is recovered
     * using the master derivation key, a key generated in this way can be
     * recovered.
     * @param walletHandle
     * @param walletPassword
     * @param addr
     */
    deleteKey(walletHandle: string, walletPassword: string, addr: string): Promise<any>;
    /**
     * ListKeys accepts a wallet handle and returns a ListKeysResponse containing
     * all of the addresses for which this wallet contains secret keys.
     * @param walletHandle
     */
    listKeys(walletHandle: string): Promise<any>;
    /**
     * signTransaction accepts a wallet handle, wallet password, and a transaction,
     * and returns and SignTransactionResponse containing an encoded, signed
     * transaction. The transaction is signed using the key corresponding to the
     * Sender field.
     * @param walletHandle
     * @param walletPassword
     * @param transaction
     */
    signTransaction(walletHandle: string, walletPassword: string, transaction: txn.TransactionLike): Promise<any>;
    /**
     * signTransactionWithSpecificPublicKey accepts a wallet handle, wallet password, a transaction, and a public key,
     * and returns and SignTransactionResponse containing an encoded, signed
     * transaction. The transaction is signed using the key corresponding to the
     * publicKey arg.
     * @param walletHandle
     * @param walletPassword
     * @param transaction
     * @param publicKey - sign the txn with the key corresponding to publicKey (used for working with a rekeyed addr)
     */
    signTransactionWithSpecificPublicKey(walletHandle: string, walletPassword: string, transaction: txn.TransactionLike, publicKey: Uint8Array | string): Promise<any>;
    /**
     * listMultisig accepts a wallet handle and returns a ListMultisigResponse
     * containing the multisig addresses whose preimages are stored in this wallet.
     * A preimage is the information needed to reconstruct this multisig address,
     * including multisig version information, threshold information, and a list
     * of public keys.
     * @param walletHandle
     */
    listMultisig(walletHandle: string): Promise<any>;
    /**
     * importMultisig accepts a wallet handle and the information required to
     * generate a multisig address. It derives this address, and stores all of the
     * information within the wallet. It returns a ImportMultisigResponse with the
     * derived address.
     * @param walletHandle
     * @param version
     * @param threshold
     * @param pks
     */
    importMultisig(walletHandle: string, version: number, threshold: number, pks: string[]): Promise<any>;
    /**
     * exportMultisig accepts a wallet handle, wallet password, and multisig
     * address, and returns an ExportMultisigResponse containing the stored
     * multisig preimage. The preimage contains all of the information necessary
     * to derive the multisig address, including version, threshold, and a list of
     * public keys.
     * @param walletHandle
     * @param walletPassword
     * @param addr
     */
    exportMultisig(walletHandle: string, addr: string): Promise<any>;
    /**
     * signMultisigTransaction accepts a wallet handle, wallet password,
     * transaction, public key (*not* an address), and an optional partial
     * MultisigSig. It looks up the secret key corresponding to the public key, and
     * returns a SignMultisigTransactionResponse containing a MultisigSig with a
     * signature by the secret key included.
     * @param walletHandle
     * @param pw
     * @param tx
     * @param pk
     * @param partial
     */
    signMultisigTransaction(walletHandle: string, pw: string, transaction: txn.TransactionLike, pk: Uint8Array | string, partial: string): Promise<any>;
    /**
     * deleteMultisig accepts a wallet handle, wallet password, and multisig
     * address, and deletes the information about this multisig address from the
     * wallet (including address and secret key).
     * @param walletHandle
     * @param walletPassword
     * @param addr
     */
    deleteMultisig(walletHandle: string, walletPassword: string, addr: string): Promise<any>;
}

fastlane_require "base64"
import "../../Fastfile"

# Update fastlane
update_fastlane

default_platform(:android)

build_number = ENV['BUILD_NUMBER'] ? ENV['BUILD_NUMBER'] : 0
android_firebase_app_id = "1:305132849030:android:6cf0cd5ec064fad3ffce07"

platform :android do
  lane :build do |options|
    if options[:type].nil? then
      return
    end

    isProd = options[:type] == 'production'
    isStaging = options[:type] == 'staging'

    build_types = get_build_type(options[:type])
    flavor = build_types["android_flavor"]

    # Flutter build
    fetch_dependencies
    build_autogenerated_code


    # Build APK

    if isProd || isStaging then
      sh_on_root(command: "flutter build apk --release --flavor #{flavor} --build-number #{build_number} --dart-define=environment=production --dart-define=SENTRY_DSN=#{ENV["SENTRY_DSN"]} --dart-define=SENTRY_PROJECT=#{ENV["SENTRY_PROJECT"]} --dart-define=SENTRY_AUTH_TOKEN=#{ENV["SENTRY_AUTH_TOKEN"]} --dart-define=SENTRY_ORG=#{ENV["SENTRY_ORG"]}")
    else
      sh_on_root(command: "flutter build apk --release --flavor #{flavor} --build-number #{build_number}")
    end

    if isProd then

      flags = ['SENTRY_DSN=' + ENV["SENTRY_DSN"],
      'SENTRY_PROJECT=' + ENV["SENTRY_PROJECT"],
      'SENTRY_AUTH_TOKEN=' + ENV["SENTRY_AUTH_TOKEN"],
      'SENTRY_ORG=' + ENV["SENTRY_ORG"]]

      b64flags = flags.map { |s| Base64.encode64(s) }.join(',')

      # Build App bundle
      gradle(
        task: "bundle",
        build_type: "Release",
        print_command: false,
        flavor: flavor,
        properties: {
          "android.injected.signing.store.file" => ENV["ANDROID_SIGNING_STORE_FILE"],
          "android.injected.signing.store.password" => ENV["ANDROID_STORE_PASSWORD"],
          "android.injected.signing.key.alias" => ENV["ANDROID_KEY_ALIAS"],
          "android.injected.signing.key.password" => ENV["ANDROID_KEY_PASSWORD"],
          "android.injected.version.code" => build_number,
        },
        flags: "-Pdart-defines=#{b64flags}"
      )
    end
  end


  lane :deploy do |options|
    if options[:type].nil? then
      return
    end

    isProd = options[:type] == 'production'
    build_types = get_build_type(options[:type])
    type = build_types["android_type"]
    flavor = build_types["android_flavor"]

    # Build Android app
    build(type: options[:type]);

    # Distribute to Firebase
    if isProd then
      firebase_app_distribution(
        app: android_firebase_app_id,
        release_notes: ENV['RELEASE_NOTES'],
        service_credentials_file: ENV['FIREBASE_JSON'],
        groups: "Testers",
        android_artifact_type: "AAB",
        android_artifact_path: "#{root_path}/build/app/outputs/bundle/#{flavor}Release/app-#{flavor}-release.aab"
      )
    else
      firebase_app_distribution(
        app: android_firebase_app_id,
        release_notes: ENV['RELEASE_NOTES'],
        service_credentials_file: ENV['FIREBASE_JSON'],
        groups: "Testers",
        android_artifact_type: "APK",
        android_artifact_path: "#{root_path}/build/app/outputs/flutter-apk/app-#{flavor}-release.apk"
      )
    end

    # FIXME: Re-enable for production release
    # if isProd then
    #   upload_to_play_store(
    #     track: type,
    #     json_key:ENV['FIREBASE_JSON'],
    #     version_code: build_number,
    #     aab: "#{root_path}/build/app/outputs/bundle/#{flavor}Release/app-#{flavor}-release.aab",
    #     skip_upload_apk: true,
    #     skip_upload_metadata: true,
    #     skip_upload_images: true,
    #     skip_upload_screenshots: true,
    #     timeout: 600
    #   )
    # end
  end

  lane :update_release_url do
    firebase_app_distribution_get_latest_release(
      app: android_firebase_app_id,
      service_credentials_file: ENV['FIREBASE_JSON']
    )

    release_name = Actions.lane_context[:FIREBASE_APP_DISTRO_LATEST_RELEASE][:name]
    release_url = get_firebase_release_url(release_name, android_firebase_app_id)

    update_pr_and_jira(release_url: release_url, ios: false)
  end
end

